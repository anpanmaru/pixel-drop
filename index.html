<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="theme-color" content="#0a0a0a">
    <title>PIXEL DROP</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            -webkit-tap-highlight-color: transparent;
            touch-action: manipulation;
        }

        html, body {
            width: 100%;
            height: 100%;
            overflow: hidden;
            background-color: transparent;
            font-family: 'SF Pro Display', -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
            color: white;
            user-select: none;
            -webkit-user-select: none;
        }

        html {
            background-color: #0a0a0a;
        }

        body {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: space-between;
            padding: env(safe-area-inset-top) env(safe-area-inset-right) env(safe-area-inset-bottom) env(safe-area-inset-left);
            min-height: 100dvh;
        }

        #backgroundCanvas {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: -1;
            pointer-events: none;
        }

        /* Main Game Container */
        .main-container {
            flex: 1;
            width: 100%;
            display: flex;
            align-items: flex-start;
            justify-content: center;
            gap: 4px;
            padding-top: 20px;
            min-height: 0;
        }

        /* Side Panels - Adjacent to game canvas */
        .side-panel {
            display: flex;
            flex-direction: column;
            gap: 4px;
            z-index: 10;
            flex-shrink: 0;
            width: 55px; /* Same width for both panels */
        }

        .side-panel.left {
            align-items: flex-end;
        }

        .side-panel.right {
            align-items: flex-start;
        }

        /* Stats (left side) */
        .stat-item {
            background: rgba(0, 0, 0, 0.6);
            backdrop-filter: blur(5px);
            -webkit-backdrop-filter: blur(5px);
            border-radius: 8px;
            padding: 4px 6px;
            text-align: center;
            width: 50px;
        }

        .stat-label {
            font-size: 0.45rem;
            font-weight: 600;
            letter-spacing: 0.5px;
            opacity: 0.6;
            text-transform: uppercase;
            margin-bottom: 2px;
        }

        .stat-value {
            font-size: 0.75rem;
            font-weight: 800;
            font-variant-numeric: tabular-nums;
            white-space: nowrap;
            overflow: hidden;
        }

        /* Next Piece Panel (left side, below stats) */
        .next-panel {
            background: rgba(0, 0, 0, 0.6);
            backdrop-filter: blur(5px);
            -webkit-backdrop-filter: blur(5px);
            border-radius: 8px;
            padding: 6px;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 2px;
        }

        .next-label {
            font-size: 0.45rem;
            font-weight: 700;
            letter-spacing: 0.5px;
            text-transform: uppercase;
            opacity: 0.6;
        }

        #nextCanvas {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 6px;
        }

        /* Circle Drop Button - Left side */
        .ctrl-btn.drop-circle {
            width: 51px;
            height: 51px;
            border-radius: 50%;
            font-size: 9px;
            font-weight: 700;
            letter-spacing: 1px;
            margin-bottom: 12px;
        }

        /* Control Buttons (right side) */
        .icon-btn {
            width: 44px;
            height: 44px;
            border-radius: 12px;
            background: rgba(0, 0, 0, 0.6);
            backdrop-filter: blur(5px);
            -webkit-backdrop-filter: blur(5px);
            border: none;
            color: white;
            font-size: 18px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.2s;
        }

        .icon-btn:active {
            transform: scale(0.95);
            background: rgba(255, 255, 255, 0.2);
        }

        /* Game Canvas - Centered and maximized */
        #gameCanvas {
            background: rgba(0, 0, 0, 0.6);
            border-radius: 8px;
            border: 2px solid rgba(255, 255, 255, 0.1);
        }

        .shake {
            animation: shake 0.25s ease-out;
        }

        @keyframes shake {
            0% { transform: translate(0, 0); }
            20% { transform: translate(-5px, 3px); }
            40% { transform: translate(4px, -2px); }
            60% { transform: translate(-3px, 1px); }
            80% { transform: translate(2px, -1px); }
            100% { transform: translate(0, 0); }
        }

        /* Controls */
        .controls {
            width: 100%;
            padding: 0px 16px 16px;
            margin-top: -8px;
            flex-shrink: 0;
            display: flex;
            justify-content: space-between;
            align-items: stretch;
            gap: 16px;
        }

        .control-side {
            display: flex;
            flex-direction: column;
            justify-content: flex-end;
            gap: 8px;
        }

        .control-side.left {
            flex-direction: column;
            align-items: flex-start;
        }

        .control-side.right {
            align-items: flex-end;
            justify-content: flex-end;
        }

        .control-side.staggered-grid {
            position: relative;
            width: 150px;
            height: 150px;
            top: 60px;
        }

        .ctrl-btn.pause-btn {
            position: absolute;
            top: 6px;
            left: 0px;
            width: 44px;
            height: 44px;
            font-size: 11px;
            font-weight: 800;
            letter-spacing: 2px;
            border-radius: 50%;
        }

        .control-row {
            display: flex;
            justify-content: center;
            gap: 8px;
        }

        .ctrl-btn {
            width: 51px;
            height: 51px;
            border-radius: 11px;
            background: rgba(255, 255, 255, 0.08);
            border: 1px solid rgba(255, 255, 255, 0.12);
            color: rgba(255, 255, 255, 0.6);
            font-size: 13px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.1s;
        }

        .ctrl-btn:active {
            transform: scale(0.95);
            background: rgba(255, 255, 255, 0.15);
            color: rgba(255, 255, 255, 0.9);
        }

        .ctrl-btn.wide {
            width: calc(90px * 2 + 4px);
            font-size: 10px;
            font-weight: 600;
            letter-spacing: 1px;
        }

        /* Button group styling for unified look */
        .btn-group {
            display: flex;
            flex-direction: column;
            gap: 3px;
        }

        .btn-group .btn-row {
            display: flex;
            gap: 3px;
        }

        .btn-group .ctrl-btn {
            border-radius: 3px;
        }

        /* Top row buttons - large rounded top corners */
        .btn-group .btn-row:first-child .ctrl-btn:first-child {
            border-top-left-radius: 20px;
        }
        .btn-group .btn-row:first-child .ctrl-btn:last-child {
            border-top-right-radius: 20px;
        }

        /* Middle buttons */
        .btn-group .ctrl-btn.move {
            border-radius: 4px;
            width: 95px;
            height: 70px;
        }

        /* Bottom button - large rounded bottom corners */
        .btn-group .ctrl-btn.down {
            border-radius: 4px 4px 20px 20px;
            width: calc(95px * 2 + 3px);
            height: 70px;
        }

        .ctrl-btn.rotate-cw,
        .ctrl-btn.rotate-ccw {
            position: absolute;
            width: 77px;
            height: 77px;
            font-size: 20px;
            border-radius: 50%;
        }

        .ctrl-btn.rotate-cw {
            top: 8px;
            right: 4px;
        }

        .ctrl-btn.rotate-ccw {
            bottom: -8px;
            left: 0px;
        }

        .ctrl-btn.move {
            width: 90px;
        }

        /* Game Over Overlay */
        /* DROP BONUS popup */
        .bonus-popup {
            position: fixed;
            top: 15%;
            left: 50%;
            transform: translate(-50%, 0) scale(0.9);
            font-size: 0.7rem;
            font-weight: 600;
            letter-spacing: 3px;
            color: rgba(255, 255, 255, 0.9);
            text-shadow: 
                0 0 10px rgba(255, 255, 255, 0.8),
                0 0 20px rgba(255, 255, 255, 0.5),
                0 0 30px rgba(255, 255, 255, 0.3);
            z-index: 500;
            pointer-events: none;
            opacity: 0;
        }

        .bonus-popup.show {
            animation: bonusPop 1s ease-out forwards;
        }

        @keyframes bonusPop {
            0% {
                transform: translate(-50%, 0) scale(0.8);
                opacity: 0;
            }
            15% {
                transform: translate(-50%, 0) scale(1.1);
                opacity: 1;
            }
            30% {
                transform: translate(-50%, 0) scale(1);
                opacity: 0.9;
            }
            70% {
                opacity: 0.7;
            }
            100% {
                transform: translate(-50%, -10px) scale(1);
                opacity: 0;
            }
        }

        .game-over {
            position: fixed;
            inset: 0;
            background: rgba(0, 0, 0, 0.8);
            backdrop-filter: blur(8px);
            -webkit-backdrop-filter: blur(8px);
            display: none;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 1000;
            padding: 20px;
        }

        .game-over.show {
            display: flex;
        }

        .game-over h2 {
            font-size: 0.9rem;
            font-weight: 600;
            letter-spacing: 2px;
            margin-bottom: 4px;
            text-transform: uppercase;
            opacity: 0.6;
        }

        .game-over .subtitle {
            font-size: 0.55rem;
            opacity: 0.4;
            margin-bottom: 12px;
            letter-spacing: 1px;
        }

        .final-score {
            font-size: 1.8rem;
            font-weight: 800;
            margin-bottom: 24px;
            color: rgba(255, 255, 255, 0.9);
        }

        .play-again-btn {
            padding: 14px 38px;
            font-size: 0.8rem;
            font-weight: 600;
            letter-spacing: 1px;
            text-transform: uppercase;
            background: rgba(255, 255, 255, 0.1);
            color: rgba(255, 255, 255, 0.8);
            border: 1px solid rgba(255, 255, 255, 0.15);
            border-radius: 12px;
            cursor: pointer;
            transition: all 0.15s;
        }

        .play-again-btn:active {
            transform: scale(0.97);
            background: rgba(255, 255, 255, 0.2);
        }

        /* Pause Overlay */
        .pause-overlay {
            position: fixed;
            inset: 0;
            background: rgba(0, 0, 0, 0.7);
            backdrop-filter: blur(5px);
            -webkit-backdrop-filter: blur(5px);
            display: none;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 999;
        }

        .pause-overlay.show {
            display: flex;
        }

        .pause-overlay h2 {
            font-size: 0.8rem;
            font-weight: 600;
            letter-spacing: 2px;
            margin-bottom: 20px;
            opacity: 0.6;
        }

        .pause-buttons {
            display: flex;
            flex-direction: column;
            gap: 10px;
            width: 168px;
        }

        .pause-action-btn {
            padding: 12px 20px;
            font-size: 0.78rem;
            font-weight: 600;
            letter-spacing: 1px;
            border: 1px solid rgba(255, 255, 255, 0.12);
            border-radius: 10px;
            cursor: pointer;
            transition: all 0.15s;
        }

        .pause-action-btn.resume {
            background: rgba(255, 255, 255, 0.1);
            color: rgba(255, 255, 255, 0.8);
        }

        .pause-action-btn.restart {
            background: rgba(255, 255, 255, 0.05);
            color: rgba(255, 255, 255, 0.6);
        }

        .pause-action-btn:active {
            transform: scale(0.97);
            background: rgba(255, 255, 255, 0.15);
        }

        /* Level Up Animation */
        .level-up {
            animation: levelUp 0.5s ease-out;
        }

        @keyframes levelUp {
            0% { transform: scale(1); }
            50% { transform: scale(1.3); color: #64ff64; }
            100% { transform: scale(1); }
        }

        /* Responsive adjustments for larger screens */
        @media (min-width: 500px) {
            .ctrl-btn {
                width: 72px;
                height: 72px;
                font-size: 18px;
            }
            .ctrl-btn.move {
                width: 100px;
            }
            .ctrl-btn.wide {
                width: calc(100px * 2 + 8px);
            }
            .ctrl-btn.rotate-cw,
            .ctrl-btn.rotate-ccw {
                width: 85px;
                height: 85px;
                font-size: 20px;
            }
        }

        @media (min-height: 800px) {
            .ctrl-btn {
                width: 72px;
                height: 72px;
                border-radius: 20px;
            }
            .ctrl-btn.move {
                width: 100px;
            }
            .ctrl-btn.wide {
                width: calc(100px * 2 + 10px);
            }
            .ctrl-btn.rotate-cw,
            .ctrl-btn.rotate-ccw {
                width: 86px;
                height: 86px;
            }
            .control-row {
                gap: 10px;
            }
            .control-side {
                gap: 10px;
            }
        }

        /* Desktop styles */
        @media (min-width: 768px) and (min-height: 600px) {
            .controls {
                max-width: 500px;
                margin: 0 auto;
            }
        }
    </style>
</head>
<body>
    <canvas id="backgroundCanvas"></canvas>

    <!-- Main Game Container -->
    <div class="main-container">
        <!-- Left Side Panel: Stats + Next -->
        <!-- Left Side Panel: Stats -->
        <div class="side-panel left">
            <div class="stat-item">
                <div class="stat-label">Score</div>
                <div class="stat-value" id="scoreValue">0</div>
            </div>
            <div class="stat-item">
                <div class="stat-label">Lv</div>
                <div class="stat-value" id="level">1</div>
            </div>
            <div class="stat-item">
                <div class="stat-label">Lines</div>
                <div class="stat-value" id="lines">0</div>
            </div>
        </div>

        <!-- Game Canvas - Center -->
        <canvas id="gameCanvas"></canvas>

        <!-- Right Side Panel: Next -->
        <div class="side-panel right">
            <div class="next-panel">
                <div class="next-label">Next</div>
                <canvas id="nextCanvas"></canvas>
            </div>
        </div>

    </div>

    <!-- Touch Controls - Two-handed layout -->
    <div class="controls">
        <!-- Left Hand: Movement -->
        <div class="control-side left">
            <button class="ctrl-btn drop-circle" id="dropBtn">DROP</button>
            <div class="btn-group">
                <div class="btn-row">
                    <button class="ctrl-btn move" id="leftBtn">◀</button>
                    <button class="ctrl-btn move" id="rightBtn">▶</button>
                </div>
                <button class="ctrl-btn wide down" id="downBtn">▼ FAST</button>
            </div>
        </div>

        <!-- Right Hand: Pause + Rotation (staggered grid layout) -->
        <!-- Grid: row1=[pause, rotate-cw], row2=[rotate-ccw, empty] -->
        <div class="control-side right staggered-grid">
            <button class="ctrl-btn pause-btn" id="pauseBtn">||</button>
            <button class="ctrl-btn rotate-cw" id="rotateCwBtn">↻</button>
            <button class="ctrl-btn rotate-ccw" id="rotateCcwBtn">↺</button>
        </div>
    </div>

    <!-- Bonus Popup -->
    <div class="bonus-popup" id="bonusPopup">DROP BONUS</div>

    <!-- Game Over Overlay -->
    <div class="game-over" id="gameOver">
        <h2>Game Over</h2>
        <div class="subtitle">FINAL SCORE</div>
        <div class="final-score" id="finalScore">0</div>
        <button class="play-again-btn" id="playAgainBtn">PLAY AGAIN</button>
    </div>

    <!-- Pause Overlay -->
    <div class="pause-overlay" id="pauseOverlay">
        <h2>PAUSED</h2>
        <div class="pause-buttons">
            <button class="pause-action-btn resume" id="resumeBtn">▶ RESUME</button>
            <button class="pause-action-btn restart" id="restartBtn">↺ RESTART</button>
        </div>
    </div>

    <script>
        // Canvas setup
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const nextCanvas = document.getElementById('nextCanvas');
        const nextCtx = nextCanvas.getContext('2d');
        const backgroundCanvas = document.getElementById('backgroundCanvas');
        const bgCtx = backgroundCanvas.getContext('2d');

        // DOM Elements
        const scoreValueEl = document.getElementById('scoreValue');
        const levelEl = document.getElementById('level');
        const linesEl = document.getElementById('lines');
        const finalScoreEl = document.getElementById('finalScore');
        const gameOverEl = document.getElementById('gameOver');
        const pauseOverlay = document.getElementById('pauseOverlay');
        const bonusPopup = document.getElementById('bonusPopup');

        function showBonusPopup() {
            bonusPopup.classList.remove('show');
            void bonusPopup.offsetWidth; // Force reflow
            bonusPopup.classList.add('show');
            if (navigator.vibrate) navigator.vibrate([30, 20, 50, 20, 80]);
        }

        // Game constants
        const BOARD_WIDTH = 10;
        const BOARD_HEIGHT = 20;
        let BLOCK_SIZE = 20;

        // Calculate optimal block size based on screen
        function calculateBlockSize() {
            const mainContainer = document.querySelector('.main-container');
            const controls = document.querySelector('.controls');
            const controlsHeight = controls ? controls.offsetHeight : 200;
            
            // Available space: full width minus side panels, height minus controls
            const availableHeight = mainContainer.clientHeight - 16;
            const availableWidth = window.innerWidth - 160; // Account for side panels
            
            const maxBlockByHeight = Math.floor(availableHeight / BOARD_HEIGHT);
            const maxBlockByWidth = Math.floor(availableWidth / BOARD_WIDTH);
            
            BLOCK_SIZE = Math.min(maxBlockByHeight, maxBlockByWidth, 32);
            BLOCK_SIZE = Math.max(BLOCK_SIZE, 16); // Minimum size
            
            canvas.width = BOARD_WIDTH * BLOCK_SIZE;
            canvas.height = BOARD_HEIGHT * BLOCK_SIZE;
            
            // Smaller next piece preview
            const nextBlockSize = Math.min(Math.floor(BLOCK_SIZE * 0.6), 16);
            nextCanvas.width = 4 * nextBlockSize;
            nextCanvas.height = 4 * nextBlockSize;
        }

        // Game state
        let patterns = {}, nextPatterns = {}, patternKeys = [], particles = [];
        let board, currentPiece, nextPiece, score, level, lines;
        let dropCounter, dropInterval, gameRunning, paused, lastTime;
        let waves = [], shockwave = 0;
        let softDropping = false;

        // Background setup
        function setupBackground() {
            backgroundCanvas.width = window.innerWidth;
            backgroundCanvas.height = window.innerHeight;
            waves = [
                { color: 'rgba(200, 80, 100, 0.25)', amplitude: 35, frequency: 0.007, phase: 0, speed: 0.004 },
                { color: 'rgba(80, 120, 200, 0.3)', amplitude: 30, frequency: 0.008, phase: 1.5, speed: 0.005 },
                { color: 'rgba(140, 80, 180, 0.25)', amplitude: 40, frequency: 0.006, phase: 3, speed: 0.004 },
                { color: 'rgba(60, 160, 140, 0.2)', amplitude: 25, frequency: 0.01, phase: 4.5, speed: 0.006 }
            ];
        }

        function drawBackground(time) {
            bgCtx.fillStyle = '#0a0a0a';
            bgCtx.fillRect(0, 0, backgroundCanvas.width, backgroundCanvas.height);
            
            const centerY = backgroundCanvas.height * 0.6;
            shockwave *= 0.95;

            waves.forEach(wave => {
                wave.phase += wave.speed;
                bgCtx.beginPath();
                bgCtx.moveTo(0, backgroundCanvas.height);
                
                for (let x = 0; x <= backgroundCanvas.width; x += 3) {
                    const amplitude = wave.amplitude + shockwave * 0.5;
                    const y = centerY + Math.sin(x * wave.frequency + wave.phase) * amplitude;
                    bgCtx.lineTo(x, y);
                }
                
                bgCtx.lineTo(backgroundCanvas.width, backgroundCanvas.height);
                bgCtx.closePath();
                bgCtx.fillStyle = wave.color;
                bgCtx.fill();
            });
        }

        // Pattern creation - Clean and crisp patterns
        function createPatternSet(context, blockSize) {
            const pSize = blockSize || 24;
            const tempPatterns = {};
            const lineW = Math.max(2, Math.floor(pSize / 8)); // Line width scales with block size
            
            const patternDefs = {
                // Solid half patterns
                'vStripes': (c, s) => {
                    c.fillStyle = '#fff';
                    c.fillRect(0, 0, s, s);
                    c.fillStyle = '#000';
                    c.fillRect(0, 0, Math.floor(s / 2), s);
                },
                'hStripes': (c, s) => {
                    c.fillStyle = '#fff';
                    c.fillRect(0, 0, s, s);
                    c.fillStyle = '#000';
                    c.fillRect(0, 0, s, Math.floor(s / 2));
                },
                // Diagonal half patterns
                'd1Stripes': (c, s) => {
                    c.fillStyle = '#fff';
                    c.fillRect(0, 0, s, s);
                    c.fillStyle = '#000';
                    c.beginPath();
                    c.moveTo(0, 0);
                    c.lineTo(s, 0);
                    c.lineTo(0, s);
                    c.closePath();
                    c.fill();
                },
                'd2Stripes': (c, s) => {
                    c.fillStyle = '#fff';
                    c.fillRect(0, 0, s, s);
                    c.fillStyle = '#000';
                    c.beginPath();
                    c.moveTo(s, 0);
                    c.lineTo(s, s);
                    c.lineTo(0, s);
                    c.closePath();
                    c.fill();
                },
                // Dot pattern
                'dots': (c, s) => {
                    c.fillStyle = '#fff';
                    c.fillRect(0, 0, s, s);
                    c.fillStyle = '#000';
                    c.beginPath();
                    c.arc(s / 2, s / 2, s / 4, 0, Math.PI * 2);
                    c.fill();
                },
                // Checker pattern
                'grid': (c, s) => {
                    c.fillStyle = '#fff';
                    c.fillRect(0, 0, s, s);
                    c.fillStyle = '#000';
                    c.fillRect(0, 0, Math.floor(s / 2), Math.floor(s / 2));
                    c.fillRect(Math.floor(s / 2), Math.floor(s / 2), Math.floor(s / 2), Math.floor(s / 2));
                },
                // LINE PATTERNS
                'vLine': (c, s) => {
                    c.fillStyle = '#fff';
                    c.fillRect(0, 0, s, s);
                    c.fillStyle = '#000';
                    c.fillRect(Math.floor((s - lineW) / 2), 0, lineW, s);
                },
                'hLine': (c, s) => {
                    c.fillStyle = '#fff';
                    c.fillRect(0, 0, s, s);
                    c.fillStyle = '#000';
                    c.fillRect(0, Math.floor((s - lineW) / 2), s, lineW);
                },
                'cross': (c, s) => {
                    c.fillStyle = '#fff';
                    c.fillRect(0, 0, s, s);
                    c.fillStyle = '#000';
                    c.fillRect(Math.floor((s - lineW) / 2), 0, lineW, s);
                    c.fillRect(0, Math.floor((s - lineW) / 2), s, lineW);
                },
                'd1Line': (c, s) => {
                    c.fillStyle = '#fff';
                    c.fillRect(0, 0, s, s);
                    c.strokeStyle = '#000';
                    c.lineWidth = lineW;
                    c.lineCap = 'square';
                    c.beginPath();
                    c.moveTo(0, s);
                    c.lineTo(s, 0);
                    c.stroke();
                },
                'd2Line': (c, s) => {
                    c.fillStyle = '#fff';
                    c.fillRect(0, 0, s, s);
                    c.strokeStyle = '#000';
                    c.lineWidth = lineW;
                    c.lineCap = 'square';
                    c.beginPath();
                    c.moveTo(0, 0);
                    c.lineTo(s, s);
                    c.stroke();
                }
            };
            
            for (const [key, drawFunc] of Object.entries(patternDefs)) {
                const pCanvas = document.createElement('canvas');
                const pCtx = pCanvas.getContext('2d');
                pCanvas.width = pSize;
                pCanvas.height = pSize;
                pCtx.imageSmoothingEnabled = false;
                drawFunc(pCtx, pSize);
                tempPatterns[key] = context.createPattern(pCanvas, 'repeat');
            }
            return tempPatterns;
        }

        // Tetromino pieces
        const PIECES = [
            { shape: [[1, 1, 1, 1]] },
            { shape: [[1, 1], [1, 1]] },
            { shape: [[0, 1, 0], [1, 1, 1]] },
            { shape: [[0, 1, 1], [1, 1, 0]] },
            { shape: [[1, 1, 0], [0, 1, 1]] },
            { shape: [[1, 0, 0], [1, 1, 1]] },
            { shape: [[0, 0, 1], [1, 1, 1]] }
        ];

        // Game initialization
        function init() {
            calculateBlockSize();
            patterns = createPatternSet(ctx, BLOCK_SIZE);
            nextPatterns = createPatternSet(nextCtx, Math.floor(BLOCK_SIZE * 0.8));
            patternKeys = [...Object.keys(patterns), null, null];
            particles = [];
            board = Array.from({ length: BOARD_HEIGHT }, () => Array(BOARD_WIDTH).fill(0));
            score = 0;
            level = 1;
            lines = 0;
            dropCounter = 0;
            dropInterval = 600;
            softDropping = false;
            gameRunning = true;
            paused = false;
            lastTime = 0;
            nextPiece = createPiece();
            spawnNewPiece();
            updateUI();
            gameOverEl.classList.remove('show');
            pauseOverlay.classList.remove('show');
            setupBackground();
            requestAnimationFrame(gameLoop);
        }

        function createPiece() {
            const shapeIndex = Math.floor(Math.random() * PIECES.length);
            const patternKey = patternKeys[Math.floor(Math.random() * patternKeys.length)];
            return {
                shape: PIECES[shapeIndex].shape,
                pattern: patternKey,
                x: Math.floor(BOARD_WIDTH / 2) - Math.floor(PIECES[shapeIndex].shape[0].length / 2),
                y: 0
            };
        }

        function spawnNewPiece() {
            currentPiece = nextPiece;
            nextPiece = createPiece();
            if (isGameOver()) gameOver();
        }

        // Game loop
        function gameLoop(time = 0) {
            drawBackground(time);

            if (!gameRunning) {
                if (particles.length > 0) {
                    draw();
                    requestAnimationFrame(gameLoop);
                }
                return;
            }

            const deltaTime = time - lastTime;
            lastTime = time;

            if (!paused) {
                dropCounter += deltaTime;
                if (dropCounter > dropInterval) pieceDrop();
                updateUI();
            }

            draw();
            requestAnimationFrame(gameLoop);
        }

        function triggerShake(intensity = 1) {
            canvas.classList.add('shake');
            shockwave = 40 + (intensity * 8);
            
            // Haptic feedback
            if (navigator.vibrate) {
                navigator.vibrate(30);
            }
            
            setTimeout(() => canvas.classList.remove('shake'), 300);
        }

        function pieceDrop() {
            if (isValidMove(currentPiece, 0, 1)) {
                currentPiece.y++;
                // FAST: 押している間1ずつスコア加算
                if (softDropping) {
                    score += 1;
                }
            } else {
                triggerShake();
                placePiece();
                clearLines();
                spawnNewPiece();
            }
            dropCounter = 0;
        }

        function isValidMove(piece, dx, dy, shape = piece.shape) {
            for (let y = 0; y < shape.length; y++) {
                for (let x = 0; x < shape[y].length; x++) {
                    if (shape[y][x]) {
                        const newX = piece.x + x + dx;
                        const newY = piece.y + y + dy;
                        if (newX < 0 || newX >= BOARD_WIDTH || newY >= BOARD_HEIGHT || (newY >= 0 && board[newY][newX])) {
                            return false;
                        }
                    }
                }
            }
            return true;
        }

        function rotatePiece(clockwise = true) {
            const originalShape = currentPiece.shape;
            let rotated;
            
            if (clockwise) {
                // Clockwise rotation (順転)
                rotated = originalShape[0].map((_, colIndex) =>
                    originalShape.map(row => row[colIndex]).reverse()
                );
            } else {
                // Counter-clockwise rotation (反転)
                rotated = originalShape[0].map((_, colIndex) =>
                    originalShape.map(row => row[row.length - 1 - colIndex])
                );
            }
            
            let offsetX = 0;
            if (!isValidMove(currentPiece, 0, 0, rotated)) {
                offsetX = currentPiece.x > BOARD_WIDTH / 2 ? -1 : 1;
                if (!isValidMove(currentPiece, offsetX, 0, rotated)) {
                    offsetX = currentPiece.x > BOARD_WIDTH / 2 ? -2 : 2;
                    if (!isValidMove(currentPiece, offsetX, 0, rotated)) return;
                }
            }
            
            currentPiece.x += offsetX;
            currentPiece.shape = rotated;
            
            // Trigger rotation animation
            rotationAnimation = 1;
            rotationDirection = clockwise ? 1 : -1;
            
            if (navigator.vibrate) navigator.vibrate(10);
        }

        function placePiece() {
            currentPiece.shape.forEach((row, y) => {
                row.forEach((value, x) => {
                    if (value) board[currentPiece.y + y][currentPiece.x + x] = { pattern: currentPiece.pattern };
                });
            });
        }

        function createParticles(x, y) {
            const particleCount = 15;
            for (let i = 0; i < particleCount; i++) {
                particles.push({
                    x: x * BLOCK_SIZE + BLOCK_SIZE / 2,
                    y: y * BLOCK_SIZE + BLOCK_SIZE / 2,
                    vx: (Math.random() - 0.5) * 4,
                    vy: (Math.random() - 0.5) * 4 - 2,
                    size: Math.random() * 3 + 1,
                    life: 60
                });
            }
        }

        function updateAndDrawParticles() {
            for (let i = particles.length - 1; i >= 0; i--) {
                const p = particles[i];
                p.vy += 0.1;
                p.x += p.vx;
                p.y += p.vy;
                p.life--;
                
                if (p.life <= 0) {
                    particles.splice(i, 1);
                } else {
                    ctx.fillStyle = `rgba(255, 255, 255, ${p.life / 60})`;
                    ctx.fillRect(p.x, p.y, p.size, p.size);
                }
            }
        }

        function clearLines() {
            let linesToClear = [];
            
            for (let y = BOARD_HEIGHT - 1; y >= 0; y--) {
                if (board[y].every(cell => cell !== 0)) {
                    linesToClear.push(y);
                    for (let x = 0; x < BOARD_WIDTH; x++) createParticles(x, y);
                }
            }
            
            if (linesToClear.length > 0) {
                // Haptic feedback for line clear
                if (navigator.vibrate) {
                    navigator.vibrate(linesToClear.length * 50);
                }
                
                linesToClear.sort((a, b) => a - b);
                for (let i = linesToClear.length - 1; i >= 0; i--) {
                    board.splice(linesToClear[i], 1);
                }
                for (let i = 0; i < linesToClear.length; i++) {
                    board.unshift(new Array(BOARD_WIDTH).fill(0));
                }
                
                lines += linesToClear.length;
                let lineScore = (linesToClear.length * 100 * linesToClear.length) * level;
                // DROPで消した場合は2倍 + ボーナス表示
                if (lastDropWasHard) {
                    lineScore *= 2;
                    showBonusPopup();
                }
                score += lineScore;
                lastDropWasHard = false;
                
                const newLevel = Math.floor(lines / 5) + 1;
                if (newLevel > level) {
                    level = newLevel;
                    if (!softDropping) {
                        dropInterval = normalDropInterval();
                    }
                    levelEl.classList.add('level-up');
                    setTimeout(() => levelEl.classList.remove('level-up'), 500);
                }
                
                updateUI();
            }
        }

        let lastDropWasHard = false;
        let hardDropRows = 0;
        let rotationAnimation = 0; // 0 to 1 for animation progress
        let rotationDirection = 1; // 1 for clockwise, -1 for counter-clockwise
        
        function hardDrop() {
            let rowsDropped = 0;
            while (isValidMove(currentPiece, 0, 1)) {
                currentPiece.y++;
                rowsDropped++;
            }
            score += rowsDropped * 5; // DROP: 高さ * 5
            hardDropRows = rowsDropped;
            lastDropWasHard = true;
            
            // Haptic feedback based on drop distance
            const vibration = Math.min(rowsDropped * 5, 50);
            if (navigator.vibrate) navigator.vibrate([vibration, 10, vibration * 1.5]);
            
            // Trigger shake with intensity based on drop distance
            triggerShake(rowsDropped);
            
            pieceDrop();
        }

        function draw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.fillStyle = 'rgba(0, 0, 0, 0.8)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Draw grid lines
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.05)';
            ctx.lineWidth = 1;
            for (let x = 0; x <= BOARD_WIDTH; x++) {
                ctx.beginPath();
                ctx.moveTo(x * BLOCK_SIZE, 0);
                ctx.lineTo(x * BLOCK_SIZE, canvas.height);
                ctx.stroke();
            }
            for (let y = 0; y <= BOARD_HEIGHT; y++) {
                ctx.beginPath();
                ctx.moveTo(0, y * BLOCK_SIZE);
                ctx.lineTo(canvas.width, y * BLOCK_SIZE);
                ctx.stroke();
            }
            
            // Draw ghost piece
            if (currentPiece) {
                let ghostY = currentPiece.y;
                while (isValidMove({ ...currentPiece, y: ghostY + 1 }, 0, 0)) {
                    ghostY++;
                }
                if (ghostY !== currentPiece.y) {
                    ctx.globalAlpha = 0.2;
                    currentPiece.shape.forEach((row, y) => {
                        row.forEach((value, x) => {
                            if (value) {
                                const px = (currentPiece.x + x) * BLOCK_SIZE;
                                const py = (ghostY + y) * BLOCK_SIZE;
                                ctx.fillStyle = '#fff';
                                ctx.fillRect(px + 1, py + 1, BLOCK_SIZE - 2, BLOCK_SIZE - 2);
                            }
                        });
                    });
                    ctx.globalAlpha = 1;
                }
            }
            
            drawBoard(board, ctx);
            if (currentPiece) drawPiece(currentPiece, ctx);
            updateAndDrawParticles();
            drawNextPiece();
        }

        function drawBoard(grid, context) {
            grid.forEach((row, y) => {
                row.forEach((cell, x) => {
                    if (cell) drawBlock(x, y, cell.pattern, context, BLOCK_SIZE);
                });
            });
        }

        function drawPiece(piece, context) {
            // Calculate piece center for rotation
            const centerX = (piece.x + piece.shape[0].length / 2) * BLOCK_SIZE;
            const centerY = (piece.y + piece.shape.length / 2) * BLOCK_SIZE;
            
            // Apply rotation animation
            if (rotationAnimation > 0) {
                // Rotation angle: starts from where it was (90° back) and rotates to current position
                const angle = -rotationAnimation * (Math.PI / 2) * rotationDirection;
                
                context.save();
                context.translate(centerX, centerY);
                context.rotate(angle);
                context.translate(-centerX, -centerY);
                
                piece.shape.forEach((row, y) => {
                    row.forEach((value, x) => {
                        if (value) drawBlock(piece.x + x, piece.y + y, piece.pattern, context, BLOCK_SIZE);
                    });
                });
                
                context.restore();
                
                // Decay animation (fast)
                rotationAnimation -= 0.15;
                if (rotationAnimation < 0) rotationAnimation = 0;
            } else {
                piece.shape.forEach((row, y) => {
                    row.forEach((value, x) => {
                        if (value) drawBlock(piece.x + x, piece.y + y, piece.pattern, context, BLOCK_SIZE);
                    });
                });
            }
        }

        function drawNextPiece() {
            const nextBlockSize = Math.floor(BLOCK_SIZE * 0.8);
            nextCtx.clearRect(0, 0, nextCanvas.width, nextCanvas.height);
            nextCtx.fillStyle = 'rgba(255, 255, 255, 0.05)';
            nextCtx.fillRect(0, 0, nextCanvas.width, nextCanvas.height);
            nextCtx.imageSmoothingEnabled = false;
            
            if (nextPiece) {
                const pieceWidth = nextPiece.shape[0].length * nextBlockSize;
                const pieceHeight = nextPiece.shape.length * nextBlockSize;
                const startX = Math.floor((nextCanvas.width - pieceWidth) / 2);
                const startY = Math.floor((nextCanvas.height - pieceHeight) / 2);
                const inset = 1;
                
                nextPiece.shape.forEach((row, y) => {
                    row.forEach((value, x) => {
                        if (value) {
                            const px = Math.floor(startX + x * nextBlockSize);
                            const py = Math.floor(startY + y * nextBlockSize);
                            const blockW = nextBlockSize - inset * 2;
                            const blockH = nextBlockSize - inset * 2;
                            
                            nextCtx.save();
                            
                            // Base block
                            nextCtx.fillStyle = '#fff';
                            nextCtx.fillRect(px + inset, py + inset, blockW, blockH);
                            
                            // Pattern
                            if (nextPiece.pattern && nextPatterns[nextPiece.pattern]) {
                                nextCtx.beginPath();
                                nextCtx.rect(px + inset, py + inset, blockW, blockH);
                                nextCtx.clip();
                                nextCtx.translate(px + inset, py + inset);
                                nextCtx.fillStyle = nextPatterns[nextPiece.pattern];
                                nextCtx.fillRect(0, 0, blockW, blockH);
                            }
                            
                            nextCtx.restore();
                            
                            // Border
                            nextCtx.strokeStyle = 'rgba(0, 0, 0, 0.1)';
                            nextCtx.lineWidth = 1;
                            nextCtx.strokeRect(px + inset + 0.5, py + inset + 0.5, blockW - 1, blockH - 1);
                        }
                    });
                });
            }
        }

        function drawBlock(x, y, patternId, context, size) {
            const px = Math.floor(x * size);
            const py = Math.floor(y * size);
            const inset = 1;
            const blockW = size - inset * 2;
            const blockH = size - inset * 2;
            const patternSet = (context === nextCtx) ? nextPatterns : patterns;
            
            context.save();
            context.imageSmoothingEnabled = false;
            
            // Draw base block
            context.fillStyle = '#fff';
            context.fillRect(px + inset, py + inset, blockW, blockH);
            
            // Apply pattern aligned to block position
            if (patternId && patternSet[patternId]) {
                context.beginPath();
                context.rect(px + inset, py + inset, blockW, blockH);
                context.clip();
                
                // Translate to align pattern with block grid
                context.translate(px + inset, py + inset);
                context.fillStyle = patternSet[patternId];
                context.fillRect(0, 0, blockW, blockH);
            }
            
            context.restore();
            
            // Add subtle white border (outside clip)
            context.strokeStyle = 'rgba(255, 255, 255, 0.5)';
            context.lineWidth = 2;
            context.strokeRect(px + inset, py + inset, blockW, blockH);
        }

        function updateUI() {
            scoreValueEl.textContent = score.toLocaleString();
            levelEl.textContent = level;
            linesEl.textContent = lines;
        }

        function isGameOver() {
            return !isValidMove(currentPiece, 0, 0);
        }

        function gameOver() {
            gameRunning = false;
            finalScoreEl.textContent = score.toLocaleString();
            gameOverEl.classList.add('show');
            
            if (navigator.vibrate) navigator.vibrate([100, 50, 100, 50, 200]);
        }

        function togglePause() {
            if (!gameRunning) return;
            paused = !paused;
            
            if (paused) {
                pauseOverlay.classList.add('show');
            } else {
                pauseOverlay.classList.remove('show');
                lastTime = performance.now();
            }
        }

        // Event listeners
        document.getElementById('pauseBtn').addEventListener('click', togglePause);
        document.getElementById('restartBtn').addEventListener('click', () => {
            pauseOverlay.classList.remove('show');
            paused = false;
            init();
        });
        document.getElementById('playAgainBtn').addEventListener('click', init);
        document.getElementById('resumeBtn').addEventListener('click', togglePause);

        // Touch controls
        // Left/Right buttons with hold-to-repeat
        let leftInterval = null;
        let rightInterval = null;
        const moveRepeatDelay = 150; // ms between moves when holding

        function moveLeft() {
            if (gameRunning && !paused && isValidMove(currentPiece, -1, 0)) {
                currentPiece.x--;
                if (navigator.vibrate) navigator.vibrate(10);
            }
        }

        function moveRight() {
            if (gameRunning && !paused && isValidMove(currentPiece, 1, 0)) {
                currentPiece.x++;
                if (navigator.vibrate) navigator.vibrate(10);
            }
        }

        function startMoveLeft() {
            if (leftInterval) return;
            moveLeft();
            leftInterval = setInterval(moveLeft, moveRepeatDelay);
        }

        function stopMoveLeft() {
            if (leftInterval) {
                clearInterval(leftInterval);
                leftInterval = null;
            }
        }

        function startMoveRight() {
            if (rightInterval) return;
            moveRight();
            rightInterval = setInterval(moveRight, moveRepeatDelay);
        }

        function stopMoveRight() {
            if (rightInterval) {
                clearInterval(rightInterval);
                rightInterval = null;
            }
        }

        const leftBtn = document.getElementById('leftBtn');
        const rightBtn = document.getElementById('rightBtn');

        // Touch events
        leftBtn.addEventListener('touchstart', (e) => { e.preventDefault(); startMoveLeft(); });
        leftBtn.addEventListener('touchend', (e) => { e.preventDefault(); stopMoveLeft(); });
        leftBtn.addEventListener('touchcancel', stopMoveLeft);

        rightBtn.addEventListener('touchstart', (e) => { e.preventDefault(); startMoveRight(); });
        rightBtn.addEventListener('touchend', (e) => { e.preventDefault(); stopMoveRight(); });
        rightBtn.addEventListener('touchcancel', stopMoveRight);

        // Mouse events
        leftBtn.addEventListener('mousedown', startMoveLeft);
        leftBtn.addEventListener('mouseup', stopMoveLeft);
        leftBtn.addEventListener('mouseleave', stopMoveLeft);

        rightBtn.addEventListener('mousedown', startMoveRight);
        rightBtn.addEventListener('mouseup', stopMoveRight);
        rightBtn.addEventListener('mouseleave', stopMoveRight);

        // Soft drop - hold to speed up
        const normalDropInterval = () => Math.max(100, 600 - (level - 1) * 50);
        const softDropInterval = 50; // Fast drop speed

        const downBtn = document.getElementById('downBtn');
        
        function startSoftDrop() {
            if (gameRunning && !paused && !softDropping) {
                softDropping = true;
                dropInterval = softDropInterval;
                if (navigator.vibrate) navigator.vibrate(10);
            }
        }
        
        function stopSoftDrop() {
            if (softDropping) {
                softDropping = false;
                dropInterval = normalDropInterval();
            }
        }
        
        // Touch events for soft drop
        downBtn.addEventListener('touchstart', (e) => {
            e.preventDefault();
            startSoftDrop();
        });
        
        downBtn.addEventListener('touchend', (e) => {
            e.preventDefault();
            stopSoftDrop();
        });
        
        downBtn.addEventListener('touchcancel', (e) => {
            stopSoftDrop();
        });
        
        // Mouse events for desktop
        downBtn.addEventListener('mousedown', startSoftDrop);
        downBtn.addEventListener('mouseup', stopSoftDrop);
        downBtn.addEventListener('mouseleave', stopSoftDrop);


        document.getElementById('rotateCwBtn').addEventListener('click', () => {
            if (gameRunning && !paused) rotatePiece(true); // Clockwise (順転)
        });

        document.getElementById('rotateCcwBtn').addEventListener('click', () => {
            if (gameRunning && !paused) rotatePiece(false); // Counter-clockwise (反転)
        });

        document.getElementById('dropBtn').addEventListener('click', () => {
            if (gameRunning && !paused) hardDrop();
        });

        // Keyboard controls (for desktop)
        document.addEventListener('keydown', (e) => {
            if (!gameRunning || paused) return;
            if (['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight', ' ', 'z', 'Z', 'x', 'X'].includes(e.key)) {
                e.preventDefault();
            }
            
            switch (e.key) {
                case 'ArrowLeft':
                    if (isValidMove(currentPiece, -1, 0)) currentPiece.x--;
                    break;
                case 'ArrowRight':
                    if (isValidMove(currentPiece, 1, 0)) currentPiece.x++;
                    break;
                case 'ArrowDown':
                    score++;
                    pieceDrop();
                    break;
                case 'ArrowUp':
                    hardDrop();
                    break;
                case ' ':
                case 'x':
                case 'X':
                    rotatePiece(true); // Clockwise
                    break;
                case 'z':
                case 'Z':
                    rotatePiece(false); // Counter-clockwise
                    break;
                case 'p':
                case 'P':
                    togglePause();
                    break;
            }
        });

        // Handle resize
        let resizeTimeout;
        window.addEventListener('resize', () => {
            clearTimeout(resizeTimeout);
            resizeTimeout = setTimeout(() => {
                setupBackground();
                calculateBlockSize();
            }, 100);
        });

        // Prevent pull-to-refresh on mobile
        document.body.addEventListener('touchmove', (e) => {
            if (e.target === document.body) {
                e.preventDefault();
            }
        }, { passive: false });

        // Initialize game
        init();
    </script>
</body>
</html>

